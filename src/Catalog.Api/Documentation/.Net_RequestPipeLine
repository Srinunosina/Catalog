
What is a MediatR:
-------------------------------------
MediatR is simply a process orchestrator.

In one sentence:
MediatR executes a request by passing it through a configurable pipeline and then into a handler.

What MediatR gives you technically
-----------------------------------
A single execution entry point (Send)
A pipeline around handlers (IPipelineBehavior)
Decoupling between caller and handler

What MediatR does not give you
-------------------------------
Architecture
DDD
Determinism
Validation
Transactions
Logging

You add those via pipeline behaviors â€” which is exactly what youâ€™re doing.


Request Pipeline:
---------------------------------------------------
Controller
  â†’ Behavior 1 (ValidationBehavior)
      â†’ Behavior 2 (LoggingBehavior)
          â†’ Behavior 3 (ExceptionHandlingBehavior)
              â†’ Actual Handler


1. ASP.NET Core middleware wraps the HTTP pipeline:
--------------------------------------------------------------

HTTP Request
  â†’ Middleware
      â†’ Routing
          â†’ Model Binding
              â†’ Controller
			  
2. MediatR behaviors wrap the Application pipeline:
--------------------------------------------------------------

Controller
  â†’ MediatR Behaviors
      â†’ Handler
          â†’ Domain
		  
Two different worlds.
Two different responsibilities.
Two different lifecycles.


3. ASP.NET Core Middleware Order (Recommended)
---------------------------------------------------
Rule:
-----
Infrastructure â†’ Observability â†’ Safety â†’ Security â†’ Routing â†’ Endpoints â†’ Dev Tools

 1ï¸.Hosting / Reverse-Proxy Infrastructure (VERY EARLY)
   
   Responsibility : Handles load balancers, HTTPS, headers.
   
   Exaple: 1. app.UseForwardedHeaders(); 2. app.UseHttpsRedirection(); 3.app.UseHsts(); // production only

   Purpose: Everything downstream depends on correct scheme, host, and headers.
   
 2. Observability & Diagnostics
 
   Responsibility : Request-level visibility.
   
   Exaple: 1. app.UseSerilogRequestLogging(); // or custom correlation-id middleware // OpenTelemetry tracing

   Purpose: Logging, tracing, metrics
    
   Not for: No business logic


HTTP
 â†“
Controller
 â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Application Pipeline         â”‚  â† Shock absorber
â”‚  â”œâ”€ Validation               â”‚
â”‚  â”œâ”€ Logging                  â”‚
â”‚  â”œâ”€ ExceptionHandling  â—„â”€â”€â”€â”€â”€â”¼â”€â”€ catches everything below
â”‚  â””â”€ Transaction              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â†“
        Application Handler
                â†“
             Domain
                â†“
         Infrastructure


ASP.NET Core (Presentation Layer)
  â””â”€â”€ Controller Action
        â””â”€â”€ mediator.Send(command)
              â””â”€â”€ MediatR Pipeline (Application Layer)
                    â”œâ”€â”€ ValidationBehavior
                    â”œâ”€â”€ LoggingBehavior
                    â”œâ”€â”€ ExceptionHandlingBehavior   ğŸ‘ˆ YOU ARE HERE
                    â””â”€â”€ Actual Handler (Use Case)
                          â””â”€â”€ Domain Layer
                                â””â”€â”€ Infrastructure

HTTP Request
   â†“
Middleware (global try/catch)
   â†“
Routing
   â†“
Model Binding
   â†“
Controller
   â†“
mediator.Send()
   â†“
MediatR Pipeline
   â†“
Handler
   â†“
Domain
   â†“
Infrastructure
   â†“
HTTP Response


src/
  Api/                         â† Presentation Layer (ASP.NET Core)
    Middleware/                â† âœ” GlobalExceptionMiddleware goes here
      GlobalExceptionMiddleware.cs
    Controllers/
    Extensions/
    Filters/                   â† (if you use them)
    Program.cs
    appsettings.json

  Application/                 â† MediatR, Behaviors, IResult, Commands, Queries
    Behaviors/
    Results/
    Handlers/
    Interfaces/

  Domain/                      â† Entities, ValueObjects, Domain Exceptions
    Entities/
    Exceptions/
    ValueObjects/
    Services/

  Infrastructure/              â† EF Core, Repositories, External Services
    Persistence/
    Services/
    Configurations/


------------ Contracts : DTO's initilization ----------------

our contract object must be:
----------------------------
1.Instantiable by the runtime
2.Writable during construction
3.Immutable after construction

This is exactly what init gives you.


-------------------------------

IEnumerable vs IReadOnlyCollection â€” When to choose what
-----------------------------------------------------
âœ” Why MediatR Behaviors typically use IEnumerable<IValidator<TRequest>>
Because the DI container resolves validators as a lazy, streaming sequence.

IEnumerable<T> is the most flexible abstraction:

Supports zero, one, or many validators

Supports lazy enumeration

Works with LINQ

Works with DIâ€™s â€œmultiple registrationsâ€ pattern

Does not require materializing the collection

âœ” When to use IReadOnlyCollection<T>
Use it when you need:

Count

Indexing

Snapshot semantics

Guarantee that the collection wonâ€™t change

âœ” Why NOT use IReadOnlyCollection here
Because:

You donâ€™t need Count

You donâ€™t need indexing

You donâ€™t need snapshot semantics

DI resolves validators lazily

IEnumerable is the idiomatic MediatR pattern

ğŸ”¥ Rule of thumb
Use IEnumerable<T> for pipelines, validators, handlers, and DIâ€‘resolved collections.

Use IReadOnlyCollection<T> when you own the collection and want to guarantee immutability.

Your current usage is correct.

2. When to use LoggingBehavior?
---------------------------------
âœ” LoggingBehavior is used for:

Request start/end logs
Performance timing
Correlation IDs
Debugging slow handlers
Observability

It is NOT for:
--------------
Validation
Exception translation
Business logic

âœ” Should you add it?
Yes â€” if you want observability and traceability.

3ï¸. Is registration order important?
------------------------------------
YES.
MediatR executes behaviors in the order they are registered.

Recommended order:
Code
1. ValidationBehavior
2. LoggingBehavior
3. ExceptionHandlingBehavior
Why?
1. ValidationBehavior first
Fastest failure

No need to log or catch anything

Prevents unnecessary handler execution

2. LoggingBehavior second
Logs the request

Logs the response

Measures performance

Wraps the handler but AFTER validation

3. ExceptionHandlingBehavior last
Catches domain exceptions

Converts them into Result.Failure

Ensures deterministic flow

This order is architecturally correct.

4ï¸âƒ£ Does ValidationBehavior run before controller action?
No â€” and this is important.

âœ” Execution order:
Code
Controller Action
    â†“
mediator.Send()
    â†“
ValidationBehavior
So validation does NOT run before the controller.

It runs after the controller calls mediator.Send(), but before the handler.

âœ” Is throwing 400 from ValidationBehavior good?
Yes â€” but not directly.

Your flow should be:

ValidationBehavior throws ValidationException

ExceptionHandlingBehavior catches it

Converts to Result.Failure

Controller maps to ProblemDetails(400)

This is deterministic and clean.

5ï¸âƒ£ What middleware belongs in the Application layer?
None.

Middleware is UI layer only.

Application layer uses Pipeline Behaviors, not middleware.

âœ” UI Layer â†’ Middleware
GlobalExceptionMiddleware

Authentication

Authorization

CORS

Routing

Swagger

âœ” Application Layer â†’ Pipeline Behaviors
ValidationBehavior

LoggingBehavior

ExceptionHandlingBehavior

PerformanceBehavior

ğŸ”¥ Rule
Middleware = HTTP pipeline  
Behaviors = Application pipeline

Your UseApplication() should remain empty â€” thatâ€™s correct.

Final Architecture (Locked Mental Model)
Code
ASP.NET Core Middleware (UI Layer)
    â†“
Controller
    â†“
ValidationBehavior
    â†“
LoggingBehavior
    â†“
ExceptionHandlingBehavior
    â†“
Handler
    â†“
Domain
    â†“
Infrastructure
This is the deterministic pipeline youâ€™ve been building.